# Integration Format Specification

**Document Type**: `integration.md`
**Purpose**: Cross-system patterns and inter-topic usage guidance
**Target**: Consumption graph output
**Generated By**: ContentGenerator tool

## Purpose

Integration documents provide guidance on using a topic in combination with other .NET technologies, frameworks, and systems. They focus on real-world scenarios where multiple technologies work together, enabling LLMs to understand and implement complex, multi-component solutions.

## Structure Requirements

### Header
```markdown
# [Topic Name] Integration

Cross-system patterns and integration approaches for [topic name].
```

### Core Sections

1. **Related Technologies** (Required)
   - Direct dependencies and complementary technologies
   - Common integration scenarios
   - Compatibility considerations

2. **Framework Integration** (Required)
   - ASP.NET Core integration patterns
   - Console application usage
   - Library development considerations

3. **Cross-Topic Patterns** (Required)
   - Integration with other documented .NET topics
   - Shared usage scenarios
   - Best practices for combined usage

4. **External System Integration** (Optional)
   - Database integration patterns
   - Cloud service integration
   - Third-party library compatibility

## Content Guidelines

### Integration Focus
- **Multi-Component**: Show how topic works with other technologies
- **Real-World**: Focus on actual development scenarios
- **Pattern-Based**: Demonstrate reusable integration approaches
- **Complete**: Show end-to-end implementation examples

### Writing Style
- **Scenario-Driven**: Organize around common integration scenarios
- **Practical**: Emphasize working implementations
- **Cross-Reference**: Link to related .NET topics appropriately
- **Comprehensive**: Cover major integration pathways

### Technical Requirements
- **Working Examples**: Integration code should be functional
- **Current Patterns**: Use modern .NET integration approaches
- **Complete Context**: Show necessary configuration and setup
- **Error Handling**: Include integration-specific error scenarios

## Content Organization

### Integration Scenario Pattern
```markdown
### [Integration Scenario Name]

**Use Case**: When and why this integration is needed
**Components**: Technologies involved in the integration
**Implementation**: Step-by-step integration approach
**Considerations**: Important factors for this integration
```

### Code Example Standards
- Show complete integration setup
- Include necessary configuration
- Demonstrate proper error handling
- Use dependency injection where appropriate

## Quality Standards

### Similarity Requirements
- Must align with golden reference integration guidance
- Should complement other document types without duplication
- Integration patterns must be technically sound

### Content Validation
- All integration examples must be technically accurate
- Patterns must reflect current .NET best practices
- Dependencies and versions must be current
- Integration approaches must be tested and verified

## Example Structure

```markdown
# File I/O Integration

Cross-system patterns and integration approaches for file operations.

## Related Technologies

### Configuration System Integration
File I/O commonly integrates with .NET configuration for managing file paths and options:

```csharp
public class FileService
{
    private readonly string _basePath;

    public FileService(IConfiguration configuration)
    {
        _basePath = configuration.GetValue<string>("Files:BasePath")
                   ?? Path.GetTempPath();
    }

    public async Task<string> ReadConfiguredFileAsync(string fileName)
    {
        var fullPath = Path.Combine(_basePath, fileName);
        return await File.ReadAllTextAsync(fullPath);
    }
}
```

### Logging Integration
File operations benefit from structured logging for troubleshooting:

```csharp
public class FileProcessor
{
    private readonly ILogger<FileProcessor> _logger;

    public FileProcessor(ILogger<FileProcessor> logger)
    {
        _logger = logger;
    }

    public async Task ProcessFileAsync(string path)
    {
        _logger.LogInformation("Processing file: {FilePath}", path);

        try
        {
            var content = await File.ReadAllTextAsync(path);
            _logger.LogDebug("Read {ByteCount} bytes from {FilePath}", content.Length, path);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to process file: {FilePath}", path);
            throw;
        }
    }
}
```

## Framework Integration

### ASP.NET Core Integration
File operations in web applications require careful consideration of paths and security:

```csharp
// Program.cs
builder.Services.AddSingleton<IFileService, FileService>();
builder.Services.Configure<FileOptions>(
    builder.Configuration.GetSection("FileOptions"));

// Controller
[ApiController]
[Route("api/[controller]")]
public class FilesController : ControllerBase
{
    private readonly IFileService _fileService;

    public FilesController(IFileService fileService)
    {
        _fileService = fileService;
    }

    [HttpPost("upload")]
    public async Task<IActionResult> UploadFile(IFormFile file)
    {
        if (file == null || file.Length == 0)
            return BadRequest("No file provided");

        await _fileService.SaveUploadedFileAsync(file);
        return Ok(new { Message = "File uploaded successfully" });
    }
}
```

### Console Application Integration
File processing applications often need command-line argument integration:

```csharp
// Program.cs
var host = Host.CreateDefaultBuilder(args)
    .ConfigureServices(services =>
    {
        services.AddSingleton<IFileProcessor, FileProcessor>();
    })
    .Build();

var processor = host.Services.GetRequiredService<IFileProcessor>();

if (args.Length == 0)
{
    Console.WriteLine("Usage: myapp <file-path>");
    return 1;
}

await processor.ProcessFileAsync(args[0]);
return 0;
```

## Cross-Topic Patterns

### System.Text.Json Integration
File I/O commonly works with JSON serialization for configuration and data files:

```csharp
public class JsonFileService<T>
{
    private readonly JsonSerializerOptions _options;

    public JsonFileService()
    {
        _options = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = true
        };
    }

    public async Task<T> ReadJsonAsync(string path)
    {
        var json = await File.ReadAllTextAsync(path);
        return JsonSerializer.Deserialize<T>(json, _options);
    }

    public async Task WriteJsonAsync(string path, T data)
    {
        var json = JsonSerializer.Serialize(data, _options);
        await File.WriteAllTextAsync(path, json);
    }
}
```

### CLI Integration
File processing often integrates with command-line interfaces:

```csharp
// Command handler that processes files
public class ProcessFileCommand
{
    [Option("-i|--input", Description = "Input file path")]
    public string InputPath { get; set; }

    [Option("-o|--output", Description = "Output file path")]
    public string OutputPath { get; set; }

    public async Task<int> OnExecuteAsync()
    {
        if (!File.Exists(InputPath))
        {
            Console.WriteLine($"Input file not found: {InputPath}");
            return 1;
        }

        var content = await File.ReadAllTextAsync(InputPath);
        var processed = ProcessContent(content);
        await File.WriteAllTextAsync(OutputPath, processed);

        Console.WriteLine($"Processing complete: {InputPath} -> {OutputPath}");
        return 0;
    }
}
```

## External System Integration

### Database Integration
File operations often complement database operations for handling attachments and exports:

```csharp
public class DocumentService
{
    private readonly DbContext _context;
    private readonly string _storagePath;

    public async Task<Document> SaveDocumentAsync(Stream fileStream, string fileName)
    {
        // Save file to disk
        var filePath = Path.Combine(_storagePath, Guid.NewGuid().ToString(), fileName);
        Directory.CreateDirectory(Path.GetDirectoryName(filePath));

        using var fileStreamOut = File.Create(filePath);
        await fileStream.CopyToAsync(fileStreamOut);

        // Save metadata to database
        var document = new Document
        {
            FileName = fileName,
            FilePath = filePath,
            CreatedAt = DateTime.UtcNow
        };

        _context.Documents.Add(document);
        await _context.SaveChangesAsync();

        return document;
    }
}
```
```

## Generation Notes

When ContentGenerator creates integration documents:

1. **Cross-Reference Analysis**: Identify integration points with other documented .NET topics
2. **Framework Awareness**: Consider major .NET frameworks and their integration patterns
3. **Real-World Focus**: Base scenarios on actual development needs
4. **Complete Examples**: Show end-to-end integration implementations
5. **Current Practices**: Use modern .NET integration approaches and patterns

Integration documents should enable LLMs to understand and implement complex, multi-component solutions that span multiple .NET technologies.