# Examples Format Specification

**Document Type**: `examples-{budget}.md`
**Purpose**: Practical code patterns and implementations within specific token budgets
**Target**: Consumption graph output
**Generated By**: ContentGenerator tool

## Purpose

Examples documents provide focused, practical code patterns that demonstrate real-world usage of a topic. They emphasize working code over conceptual explanations, enabling LLMs to understand implementation patterns and generate similar code.

## Document Variants

### `examples-800.md` - Focused Examples
- **Token Budget**: 800 tokens
- **Scope**: Essential usage patterns with concise explanations
- **Code Ratio**: ~70% code, 30% explanation

### `examples-1600.md` - Extended Examples
- **Token Budget**: 1600 tokens
- **Scope**: Comprehensive patterns with context and variations
- **Code Ratio**: ~65% code, 35% explanation

## Structure Requirements

### Header
```markdown
# [Topic Name] Examples

Practical code examples and patterns for [topic name].
```

### Core Sections

1. **Basic Usage** (Required)
   - Simplest working example
   - Minimal setup and configuration
   - Clear, commented code

2. **Common Patterns** (Required)
   - Most frequently used implementations
   - Real-world scenarios
   - Multiple variations of core usage

3. **Advanced Scenarios** (Required for 1600, Optional for 800)
   - Complex use cases
   - Error handling patterns
   - Performance optimizations

4. **Integration Examples** (Optional)
   - Cross-topic usage patterns
   - Working with related .NET features
   - Complete application scenarios

## Content Guidelines

### Code Quality Standards
- **Runnable**: Examples should compile and execute
- **Realistic**: Reflect actual development scenarios
- **Complete**: Include necessary using statements and setup
- **Commented**: Brief explanations of key lines
- **Current**: Use modern .NET patterns and APIs

### Explanation Style
- **Concise**: Minimal explanatory text
- **Focused**: Explain the "what" and "why" briefly
- **Practical**: Emphasize usage implications
- **Code-Centric**: Let code demonstrate concepts

### Example Selection Criteria
- **Frequency**: Include most commonly encountered patterns
- **Difficulty Progression**: Start simple, build complexity
- **Completeness**: Cover essential scenarios within budget
- **Diversity**: Show different approaches to similar problems

## Token Budget Strategy

### Budget Allocation Guidelines

#### 800 Token Budget
- **Basic Usage**: ~250 tokens (31%)
- **Common Patterns**: ~450 tokens (56%)
- **Advanced Scenarios**: ~100 tokens (13%)

#### 1600 Token Budget
- **Basic Usage**: ~400 tokens (25%)
- **Common Patterns**: ~800 tokens (50%)
- **Advanced Scenarios**: ~300 tokens (19%)
- **Integration Examples**: ~100 tokens (6%)

### Code-to-Explanation Ratio
- **800 tokens**: 70% code, 30% explanation
- **1600 tokens**: 65% code, 35% explanation

## Quality Standards

### Similarity Requirements
- Must maintain >0.7 similarity to corresponding `golden-reference.md`
- Focus on implementation patterns rather than conceptual similarity
- Code examples should reflect golden reference best practices

### Token Budget Validation
- **Acceptable**: Within 10% of target budget
- **Warning**: 20% or more under budget
- **Error**: More than 10% over budget

### Code Validation
- All examples must be syntactically correct
- Examples must use current .NET APIs and patterns
- Code should follow established .NET conventions

## Example Structure

### Focused Examples (800 tokens)
```markdown
# File I/O Examples

Practical code examples for file operations in .NET.

## Basic Usage

### Reading a Text File
```csharp
using System.IO;

// Read entire file
string content = File.ReadAllText("data.txt");

// Read all lines
string[] lines = File.ReadAllLines("data.txt");
```

### Writing a Text File
```csharp
// Write string to file
File.WriteAllText("output.txt", content);

// Write lines to file
File.WriteAllLines("output.txt", lines);
```

## Common Patterns

### Async File Operations
```csharp
using System.IO;

public async Task ProcessFileAsync(string path)
{
    string content = await File.ReadAllTextAsync(path);
    await File.WriteAllTextAsync("processed.txt", content.ToUpper());
}
```

### Stream-Based Reading
```csharp
using (var reader = new StreamReader("large-file.txt"))
{
    string line;
    while ((line = reader.ReadLine()) != null)
    {
        Console.WriteLine(line);
    }
}
```

## Advanced Scenarios

### File Operations with Error Handling
```csharp
try
{
    string content = File.ReadAllText(path);
    return content;
}
catch (FileNotFoundException)
{
    return string.Empty;
}
catch (UnauthorizedAccessException ex)
{
    throw new InvalidOperationException($"Access denied: {path}", ex);
}
```
```

### Extended Examples (1600 tokens)
```markdown
# System.Text.Json Examples

Comprehensive code examples for JSON operations in .NET.

## Basic Usage

### Simple Serialization
```csharp
using System.Text.Json;

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
}

var person = new Person { Name = "John", Age = 30 };
string json = JsonSerializer.Serialize(person);
// Output: {"Name":"John","Age":30}
```

### Simple Deserialization
```csharp
string json = """{"Name":"Jane","Age":25}""";
var person = JsonSerializer.Deserialize<Person>(json);
```

## Common Patterns

### Custom Serialization Options
```csharp
var options = new JsonSerializerOptions
{
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
    WriteIndented = true,
    PropertyNameCaseInsensitive = true
};

string json = JsonSerializer.Serialize(person, options);
var deserialized = JsonSerializer.Deserialize<Person>(json, options);
```

### Working with Collections
```csharp
var people = new List<Person>
{
    new Person { Name = "Alice", Age = 28 },
    new Person { Name = "Bob", Age = 35 }
};

string json = JsonSerializer.Serialize(people);
var deserializedList = JsonSerializer.Deserialize<List<Person>>(json);
```

## Advanced Scenarios

### Custom Converters
```csharp
public class DateOnlyConverter : JsonConverter<DateOnly>
{
    public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        return DateOnly.Parse(reader.GetString());
    }

    public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
    {
        writer.WriteStringValue(value.ToString("yyyy-MM-dd"));
    }
}

var options = new JsonSerializerOptions();
options.Converters.Add(new DateOnlyConverter());
```

### Async Stream Processing
```csharp
public async Task<List<Person>> ReadJsonStreamAsync(Stream stream)
{
    return await JsonSerializer.DeserializeAsync<List<Person>>(stream);
}

public async Task WriteJsonStreamAsync(Stream stream, List<Person> people)
{
    await JsonSerializer.SerializeAsync(stream, people);
}
```

## Integration Examples

### Web API Integration
```csharp
// Configure in Program.cs
builder.Services.ConfigureHttpJsonOptions(options =>
{
    options.SerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;
});

// Controller action
[HttpPost]
public IActionResult CreatePerson([FromBody] Person person)
{
    // person automatically deserialized from JSON
    return Ok(new { Message = "Created", Data = person });
}
```
```

## Generation Notes

When ContentGenerator creates examples documents:

1. **Pattern Analysis**: Identify most common usage patterns from golden reference
2. **Code Focus**: Prioritize working code over explanatory text
3. **Progression**: Order examples from simple to complex
4. **Completeness**: Ensure examples cover essential scenarios within budget
5. **Realism**: Base examples on real-world development patterns

Examples documents should enable LLMs to generate similar, working code patterns for the topic.